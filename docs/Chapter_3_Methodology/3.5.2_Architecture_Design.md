# 3.5.2 Architecture Design

The Nexus Event Management System adopts a three-tier architecture that separates the presentation, application logic, and data management responsibilities. This structure leverages the strengths of the MERN stack while maintaining clear boundaries between user interface rendering, business rule execution, and persistent storage.

- **Presentation Layer (Client Tier)**: Implemented with React and Vite, this layer delivers a responsive single-page application for all user roles. Components handle routing, state management, and data visualisation for features such as the organizer dashboard, Leaflet-powered event maps, and QR code ticket wallets. API communication occurs via Axios with JWT-secured headers.
- **Application/Logic Layer (Middle Tier)**: Powered by Node.js and Express, this layer encapsulates the MVC controllers, middleware, and service integrations. It coordinates authentication, event lifecycle management, Paystack payment flows, and organizer analytics. Centralised middleware enforces authorization policies for guests, organizers, and admins.
- **Data Layer (Persistence Tier)**: MongoDB, accessed through Mongoose, persists domain entities (`User`, `Event`, `Ticket`) and maintains indexes for efficient querying. This tier also stores transactional metadata such as payment references and check-in timestamps. The flexible schema supports rapid iteration while preserving referential integrity via `ObjectId` references.

This layered design supports horizontal scaling, simplifies unit and integration testing, and aligns with the deployment strategy where the frontend can be hosted as static assets (e.g., on Vercel or Netlify) while the API and database run on containerised infrastructure.

## Class Diagram Narrative
The conceptual class diagram for Nexus highlights four primary classes and their relationships:

- **User**: Represents individuals interacting with the platform. Attributes include `name`, `email`, `password`, `role`, `profilePicture`, `accentPreference`, and arrays such as `notificationReads` and `interests`. Roles (`student`, `organizer`, `admin`) determine available operations. One `User` can author multiple `Event` objects and can own multiple `Ticket` objects.

- **Event**: Captures organizer-created experiences with attributes such as `title`, `description`, `date`, `location`, `registrationFee`, `capacity`, `status`, `tags`, `imageUrl`, and geographic coordinates. Each `Event` is linked to exactly one `User` (the organizer) but can aggregate many `Ticket` instances associated with attendees.

- **Ticket**: Encodes the transactional relationship between a guest and an event. Key attributes include foreign keys `user` and `event`, `quantity`, `status` (`pending`, `confirmed`, `checked-in`), `paymentReference`, `amountPaid`, `checkedInAt`, and `metadata`. A single `Ticket` belongs to one `User` and one `Event`, but a user can hold multiple tickets across different events. The class also records the lifecycle required for QR check-in.

- **Payment (Service Abstraction)**: While payment data is embedded within the `Ticket` model, the design treats Paystack interactions as a dedicated service class. Responsibilities include initiating transactions, verifying callbacks, and mapping Paystack references back to `Ticket` instances. This abstraction isolates external dependencies and simplifies future migration to alternative payment gateways.

Associations in the diagram therefore include one-to-many from `User` to `Event`, one-to-many from `Event` to `Ticket`, and one-to-one between `Ticket` and `Payment` (service interaction). Generalisation is used to illustrate role-based behaviour extensions for the `User` class, whereas composition highlights how `Ticket` cannot exist without both linked entities.

## Package Diagram Narrative
The package structure follows Node.js conventions while reinforcing the three-tier separation:

- `client/src/components`, `client/src/pages`, and `client/src/hooks` constitute the presentation packages, encapsulating UI widgets, route-level views, and shared client logic.
- `server/controllers`, `server/routes`, and `server/middleware` implement the application layer, providing cohesive modules for organizer operations, ticketing, authentication, and payment callbacks.
- `server/models` and `server/utils` compose the data access and infrastructure packages, defining Mongoose schemas, indexes, and auxiliary helpers (e.g., file uploads).

This modular organisation ensures that each package exposes well-defined interfaces, minimises coupling, and supports collaborative development across the project team.
